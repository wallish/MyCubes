<html>
<head>
    <meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<title>My cube</title>
<style>canvas { width: 100%; height: 100%; } body{margin:0; padding:0; overflow:hidden;}</style>
</head>
<body>
<script src="http://threejs.org/build/three.min.js"></script>
<script>
 
        //init var
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
        var renderer = new THREE.WebGLRenderer();
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        var geometry = new THREE.BoxGeometry(200, 200, 200, 2, 2, 2);
        var material = new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
        var cube = new THREE.Mesh(geometry, material);
        var uping = [];
        var cubes = [];
        projector = new THREE.Projector();
        cubes.push(cube);
        scene.add(cube);
      	//document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        //document.addEventListener( 'click', onDocumentMouseMove, false );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
 
        camera.position.z = 1000;
 
                                
        function onDocumentMouseMove( event ) {
            event.preventDefault();

            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function addCube()
        {
            if(onClickCube()){
                var geometry = new THREE.BoxGeometry(200, 200, 200, 2, 2, 2);
                var material = new THREE.MeshBasicMaterial({color: Math.random() * 0xfffff, wireframe: true});
                var cube = new THREE.Mesh(geometry, material);
                cube.position.x = Math.floor((Math.random() * window.innerWidth) + 1)
                cube.position.y = Math.floor((Math.random() * window.innerHeight) + 1)
                cubes.push(cube);
                scene.add(cube);
                //console.log( Math.floor((Math.random() * window.innerWidth) + 1));

            }
        }

        function onDocumentMouseDown(event) {
	        event.preventDefault();

	        mouseDown = true;
	        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            changeCubeColor();
            addCube();

    	}
 
        function changeCubeColor () {
          
            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
            projector.unprojectVector( vector, camera );
            raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

            var intersects = raycaster.intersectObjects( scene.children);
            if(intersects.length > 0) intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
        }

        function onClickCube () {
          
            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
            projector.unprojectVector( vector, camera );
            raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

            var intersects = raycaster.intersectObjects( scene.children);
            return (intersects.length > 0) ? true : false;
        }

        function collision(){
            for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
            {       
                var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
                var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
                var directionVector = globalVertex.sub( MovingCube.position );

                var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
                var collisionResults = ray.intersectObjects( collidableMeshList );
                if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
                console.log(" Hit ");
            }
        }

        function hit(){

        }

        //render
        function render() {
            requestAnimationFrame(render);
            //console.log(camera.position)
           
            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );

            projector.unprojectVector( vector, camera );
            raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

             
            for (var i = cubes.length - 1; i >= 0; i--) {
                cubes[i].rotation.x += 0.01;
                cubes[i].rotation.y += 0.01;
                if(!uping[i]) cubes[i].position.y -= 2;
                if(Math.abs(cubes[i].position.y) > window.innerHeight || uping[i] == true){
                uping[i] = true;
                 //addCube();
                cubes[i].position.y += 2;
                if(cubes[i].position.y > 1)
               
                    uping[i] = false;
              
                }
                
            };
            renderer.render(scene, camera);
        };
 
        render();
</script>
</body>
</html>